// data files, each row represents an instance.
provider = "csvReader"   // csvReader or mySQLDB

outputFile = "result"   // name only, no extension
outputFormat = "txt"   // "txt" or "json"

csvReader {
  dataFiles = ["data/connect-4.0.csv"]
  dataFilesHaveHeader = true
  // Separator used in the data files as string
  separator = ","
  // quoteCharacter =
  // escxapeCharacter
}

mySQLDB {
  host = "localhost"
  port = 3306
  database = "connect4"
  table = "connect4"
  user = "root"
  password = "poignepoigne"
}

// minimal quality
minimalQuality = 0.0
// minimal generality
minGenerality = 0.0
// minimal probability
minProbability = 0.0

// if true, the closure of the k best subgroups are computed.
computeClosureOfSubgroups = false
// if true, the refinements of subgroups are computed.
refineSubgroups = false

// Supported quality functions are presently Piatetsky (Default),Binomial, Split, Pearson, and Gini
qualityfunction = "Piatetsky"

// List of attributes
attributes = [
  {name = "a1", typ = "Nominal"},
  {name = "a2", typ = "Nominal"},
  {name = "a3", typ = "Nominal"},
  {name = "a4", typ = "Nominal"},
  {name = "a5", typ = "Nominal"},
  {name = "a6", typ = "Nominal"},
  {name = "b1", typ = "Nominal"},
  {name = "b2", typ = "Nominal"},
  {name = "b3", typ = "Nominal"},
  {name = "b4", typ = "Nominal"},
  {name = "b5", typ = "Nominal"},
  {name = "b6", typ = "Nominal"},
  {name = "c1", typ = "Nominal"},
  {name = "c2", typ = "Nominal"},
  {name = "c3", typ = "Nominal"},
  {name = "c4", typ = "Nominal"},
  {name = "c5", typ = "Nominal"},
  {name = "c6", typ = "Nominal"},
  {name = "d1", typ = "Nominal"},
  {name = "d2", typ = "Nominal"},
  {name = "d3", typ = "Nominal"},
  {name = "d4", typ = "Nominal"},
  {name = "d5", typ = "Nominal"},
  {name = "d6", typ = "Nominal"},
  {name = "e1", typ = "Nominal"},
  {name = "e2", typ = "Nominal"},
  {name = "e3", typ = "Nominal"},
  {name = "e4", typ = "Nominal"},
  {name = "e5", typ = "Nominal"},
  {name = "e6", typ = "Nominal"},
  {name = "f1", typ = "Nominal"},
  {name = "f2", typ = "Nominal"},
  {name = "f3", typ = "Nominal"},
  {name = "f4", typ = "Nominal"},
  {name = "f5", typ = "Nominal"},
  {name = "f6", typ = "Nominal"},
  {name = "g1", typ = "Nominal"},
  {name = "g2", typ = "Nominal"},
  {name = "g3", typ = "Nominal"},
  {name = "g4", typ = "Nominal"},
  {name = "g5", typ = "Nominal"},
  {name = "g6", typ = "Nominal"},
  {name = "Class", typ = "Nominal"}
]

groups = [
  //  {name = x1, group = [f1, g1]},
  //  {name = x2, group = [f2, g2]}
]


// name of the target attribute
// all values of the target attribute not listed in "groups" are subsumed to a group "default".

target {
  name = "Class",
  groups = ["win"]
}

// If true, overlapping intervals are generated and used in case of numerical values.
useOverlappingIntervals = false

discretisation = {
  intervalBinning = [
    {
      features = [],
      ranges = [{lo = 0.0, hi = 1.0}]

    }
  ],
  equalFrequencyBinning = [
    {
      features = [],
      bins = 0
    }
  ]
  equalWidthBinning = [
    {
      features = [],
      bins = 0
    }
  ]
  entropyBinning = [
    {
      features = [],
      bins = 0
    }
  ]
}


//// Different discretisation methods are supported. For each method, there are two cases: (a) discretisation applies to all attributes uniformly, (b) discretisation applies to specific attributes. In the latter case, the method may be mixed, but the list of attributes should be disjoint.
//discretisation {
//  type = “none”
//  delimiters = [{attribute = "all", values = []}]
//  frequency = [{attribute = "all", values = []}]
//}

//// The numerical values determine the limit points. Given the limit points l1,…, ln, the generated intervals are  (-maxval,l1], (l1,l2], … , (ln, maxval].
//"discretisation_method": {
//  “delimiters”: [{“attribute_1”: [list of numerical values], …, { “attribute_m”: [list of numerical values]}
//    // similar to above, but with attributes specified
//    "discretisation_method" : {“frequency”: number of bins (integer)}
//    // The values are split so that every bin holds the same number of values (+/- 1)
//    "discretisation_method" : {
//      “frequency”: [{“attribute_1”: number of bins (integer), …, { “attribute_m”: number of bins (integer)] }
//        // similar to above, but with attributes specified
//        "discretisation_method" : {“frequency”: number of bins (integer)}
//        // The values are split according to modified entropy discretisation. Entropy discretisation is modified in that discretisation is continued until the number of specified bins is reached, even if (standard) discretisation would stop due to the standard termination condition.
//        "discretisation_method" : {
//          “frequency”: [{“attribute_1”: number of bins (integer), …, { “attribute_m”: number of bins (integer)] }
//            // similar to above, but with attributes specified
//            "filter" : [list of attributes (string) to be considered]
//          // If the ‘filter’ is not included, default is all attributes minus the target attribute.
//        }
